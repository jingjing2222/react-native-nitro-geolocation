# iOS LocationManager ÏÑ±Îä• Í∞úÏÑ† Í∞ÄÏù¥Îìú

## Î™©Ï∞®
1. [Í∞úÏöî](#Í∞úÏöî)
2. [ÌïµÏã¨ Í∞úÏÑ† ÏÇ¨Ìï≠](#ÌïµÏã¨-Í∞úÏÑ†-ÏÇ¨Ìï≠)
3. [Í∞úÏÑ† ÏΩîÎìú](#Í∞úÏÑ†-ÏΩîÎìú)
4. [Ï†ÅÏö© ÏàúÏÑú](#Ï†ÅÏö©-ÏàúÏÑú)
5. [ÏòàÏÉÅ ÏÑ±Îä• Ìñ•ÏÉÅ](#ÏòàÏÉÅ-ÏÑ±Îä•-Ìñ•ÏÉÅ)

---

## Í∞úÏöî

ÌòÑÏû¨ Nitro GeolocationÏùò iOS Íµ¨ÌòÑÏùÄ `@react-native-community/geolocation` ÎåÄÎπÑ 20-40% ÎäêÎ¶ΩÎãàÎã§.
Ï£ºÏöî ÏõêÏù∏ÏùÄ **Î∂àÌïÑÏöîÌïú Main Queue ÏÇ¨Ïö©**Í≥º **ÎèôÍ∏∞ Î∏îÎ°úÌÇπ**ÏûÖÎãàÎã§.

Ïù¥ Î¨∏ÏÑúÎäî **50-80% ÏÑ±Îä• Ìñ•ÏÉÅ**ÏùÑ ÏúÑÌïú Íµ¨Ï≤¥Ï†ÅÏù∏ Í∞úÏÑ† Î∞©ÏïàÏùÑ Ï†úÏãúÌï©ÎãàÎã§.

---

## ÌïµÏã¨ Í∞úÏÑ† ÏÇ¨Ìï≠

### Î¨∏Ï†ú ÏöîÏïΩ

| Î¨∏Ï†ú | ÌòÑÏû¨ ÏÉÅÌÉú | ÏòÅÌñ•ÎèÑ |
|------|-----------|--------|
| Main Queue ÏÇ¨Ïö© | Î™®Îì† Ìï®ÏàòÏóêÏÑú `DispatchQueue.main.async/sync` ÏÇ¨Ïö© | üî¥ ÎÜíÏùå (30-50%) |
| Timer Íµ¨ÌòÑ | `Timer` ÏÇ¨Ïö© (Run loop ÌïÑÏöî) | üî¥ ÎÜíÏùå (10-15%) |
| watchPosition sync | `DispatchQueue.main.sync`Î°ú JS thread Î∏îÎ°úÌÇπ | üî¥ ÎÜíÏùå (20-30%) |
| Configuration ÏàúÌöå | Îß§Î≤à Ï†ÑÏ≤¥ Î∞∞Ïó¥ ÏàúÌöå O(n) | üü° Ï§ëÍ∞Ñ (5-10%) |
| Î∂àÌïÑÏöîÌïú weak self | Î™®Îì† ÌÅ¥Î°úÏ†ÄÏóêÏÑú guard Ï≤¥ÌÅ¨ | üü¢ ÎÇÆÏùå (1-2%) |

### Ìï¥Í≤∞ Î∞©Ïïà

1. **Main Queue ‚Üí Ï†ÑÏö© Serial Queue**
   - UIÏôÄ Í≤ΩÌï© Ï†úÍ±∞
   - sync ÏïàÏ†ÑÌïòÍ≤å ÏÇ¨Ïö© Í∞ÄÎä•
   - Context switch Í∞êÏÜå

2. **Timer ‚Üí DispatchSourceTimer**
   - Run loop Î∂àÌïÑÏöî
   - Ï†ÑÏö© queueÏóêÏÑú ÏßÅÏ†ë Ïã§Ìñâ

3. **Configuration Î°úÏßÅ Í∞ÑÏÜåÌôî**
   - Ï†ÑÏ≤¥ ÏàúÌöå Ï†úÍ±∞
   - Ï∫êÏã± ÎòêÎäî Ï≤´ Î≤àÏß∏ ÏòµÏÖòÎßå ÏÇ¨Ïö©

---

## Í∞úÏÑ† ÏΩîÎìú

### 1. Ï†ÑÏö© Serial Queue ÎèÑÏûÖ

#### Before (ÌòÑÏû¨)
```swift
class LocationManager: NSObject, CLLocationManagerDelegate {
    private var locationManager: CLLocationManager?
    private var nextWatchId: Double = 1
    private var activeWatches: [Double: WatchSubscription] = [:]

    func getCurrentPosition(
        success: @escaping (GeolocationResponse) -> Void,
        error: ((GeolocationError) -> Void)?,
        options: GeolocationOptions?
    ) {
        DispatchQueue.main.async { [weak self] in  // ‚ùå Main queue!
            guard let self = self else { return }

            let parsedOptions = ParsedOptions.parse(from: options)
            // ... Î°úÏßÅ
        }
    }

    func watchPosition(
        success: @escaping (GeolocationResponse) -> Void,
        error: ((GeolocationError) -> Void)?,
        options: GeolocationOptions?
    ) -> Double {
        var resultWatchId: Double = 0

        DispatchQueue.main.sync { [weak self] in  // ‚ùå JS thread Î∏îÎ°úÌÇπ!
            guard let self = self else { return }

            let watchId = self.nextWatchId
            self.nextWatchId += 1
            // ... Îì±Î°ù Î°úÏßÅ
            resultWatchId = watchId
        }

        return resultWatchId
    }
}
```

#### After (Í∞úÏÑ†)
```swift
class LocationManager: NSObject, CLLocationManagerDelegate {
    // ‚úÖ Ï†ÑÏö© Serial Queue ÏÉùÏÑ±
    private let locationQueue = DispatchQueue(
        label: "com.nitro.geolocation",
        qos: .userInitiated
    )

    private var locationManager: CLLocationManager?
    private var nextWatchId: Double = 1
    private var activeWatches: [Double: WatchSubscription] = [:]

    func getCurrentPosition(
        success: @escaping (GeolocationResponse) -> Void,
        error: ((GeolocationError) -> Void)?,
        options: GeolocationOptions?
    ) {
        locationQueue.async { [weak self] in  // ‚úÖ Ï†ÑÏö© queue
            guard let self = self else { return }

            let parsedOptions = ParsedOptions.parse(from: options)

            // Authorization check
            let status = CLLocationManager.authorizationStatus()
            if status == .denied || status == .restricted {
                let message = status == .restricted
                    ? "This application is not authorized to use location services"
                    : "User denied access to location services."
                error?(self.createError(code: self.PERMISSION_DENIED, message: message))
                return
            }

            if !CLLocationManager.locationServicesEnabled() {
                error?(self.createError(
                    code: self.POSITION_UNAVAILABLE,
                    message: "Location services disabled."
                ))
                return
            }

            // Check cached location
            if let cached = self.lastLocation,
               self.isCachedLocationValid(cached, options: parsedOptions) {
                success(self.locationToPosition(cached))
                return
            }

            self.initializeLocationManagerIfNeeded()

            // Create request
            var request = LocationRequest(
                success: success,
                error: error,
                options: parsedOptions,
                timer: nil
            )

            // Setup timeout timer (DispatchSourceTimerÎ°ú Î≥ÄÍ≤Ω - ÏïÑÎûò Ï∞∏Ï°∞)
            let timer = self.createTimeoutTimer(
                timeout: parsedOptions.timeout,
                request: request
            )
            request.timer = timer

            self.pendingRequests.append(request)

            // Configure and start
            self.locationManager?.desiredAccuracy = parsedOptions.accuracy
            self.locationManager?.distanceFilter = parsedOptions.distanceFilter
            self.startMonitoring()
        }
    }

    func watchPosition(
        success: @escaping (GeolocationResponse) -> Void,
        error: ((GeolocationError) -> Void)?,
        options: GeolocationOptions?
    ) -> Double {
        // ‚úÖ Sync ÏÇ¨Ïö© Í∞ÄÎä•! (Ï†ÑÏö© queueÎùº ÏïàÏ†Ñ)
        return locationQueue.sync { [weak self] in
            guard let self = self else { return 0 }

            let watchId = self.nextWatchId
            self.nextWatchId += 1

            let parsedOptions = ParsedOptions.parse(from: options)
            let subscription = WatchSubscription(
                success: success,
                error: error,
                options: parsedOptions
            )

            self.activeWatches[watchId] = subscription

            self.initializeLocationManagerIfNeeded()

            // ÏßÅÏ†ë ÏÑ§Ï†ï (updateLocationManagerConfiguration Ï†úÍ±∞)
            self.locationManager?.desiredAccuracy = parsedOptions.accuracy
            self.locationManager?.distanceFilter = parsedOptions.distanceFilter
            self.startMonitoring()

            return watchId
        }
    }

    func clearWatch(watchId: Double) {
        locationQueue.async { [weak self] in  // ‚úÖ Ï†ÑÏö© queue
            guard let self = self else { return }

            self.activeWatches.removeValue(forKey: watchId)

            if self.activeWatches.isEmpty && self.pendingRequests.isEmpty {
                self.stopMonitoring()
            }
        }
    }

    func stopObserving() {
        locationQueue.async { [weak self] in  // ‚úÖ Ï†ÑÏö© queue
            guard let self = self else { return }

            self.activeWatches.removeAll()

            if self.pendingRequests.isEmpty {
                self.stopMonitoring()
            }
        }
    }

    func requestAuthorization(
        authType: AuthorizationType,
        skipPermissionRequests: Bool,
        enableBackgroundLocationUpdates: Bool,
        success: (() -> Void)?,
        error: ((GeolocationError) -> Void)?
    ) {
        locationQueue.async { [weak self] in  // ‚úÖ Ï†ÑÏö© queue
            guard let self = self else { return }

            self.initializeLocationManagerIfNeeded()
            self.enqueueAuthorizationCallbacks(success: success, error: error)

            if skipPermissionRequests {
                if enableBackgroundLocationUpdates {
                    self.enableBackgroundLocationUpdatesIfNeeded()
                }
                self.handleAuthorizationSuccess()
                return
            }

            let currentStatus = CLLocationManager.authorizationStatus()
            if currentStatus == .authorizedAlways || currentStatus == .authorizedWhenInUse {
                self.handleAuthorizationSuccess()
                return
            }

            if currentStatus == .denied || currentStatus == .restricted {
                self.handleAuthorizationError(for: currentStatus)
                return
            }

            self.requestPermission(for: authType)
        }
    }

    // MARK: - CLLocationManagerDelegate
    // ‚úÖ Delegate ÏΩúÎ∞±ÎèÑ locationQueueÏóêÏÑú Ïã§ÌñâÎê®!
    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        // Ïù¥ÎØ∏ locationQueue context (async Î∂àÌïÑÏöî!)
        let status = getCurrentAuthorizationStatus(from: manager)

        switch status {
        case .authorizedAlways, .authorizedWhenInUse:
            handleAuthorizationSuccess()
            startMonitoring()
        case .denied, .restricted:
            handleAuthorizationError(for: status)
        case .notDetermined:
            break
        @unknown default:
            break
        }
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        // Ïù¥ÎØ∏ locationQueue context (async Î∂àÌïÑÏöî!)
        guard let location = locations.last else { return }

        lastLocation = location
        let position = locationToPosition(location)

        // 1. Fire all pending getCurrentPosition requests
        for request in pendingRequests {
            request.timer?.cancel()
            request.success(position)
        }
        pendingRequests.removeAll()

        // 2. Fire all active watchPosition subscriptions
        for (_, watch) in activeWatches {
            watch.success(position)
        }

        // 3. Stop monitoring if no more watches or pending requests
        if activeWatches.isEmpty && pendingRequests.isEmpty {
            stopMonitoring()
        }
    }

    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        // Ïù¥ÎØ∏ locationQueue context
        let geoError: GeolocationError

        if let clError = error as? CLError {
            switch clError.code {
            case .denied:
                geoError = createError(
                    code: PERMISSION_DENIED,
                    message: "User denied access to location services."
                )
            case .locationUnknown:
                return
            default:
                geoError = createError(
                    code: POSITION_UNAVAILABLE,
                    message: "Unable to retrieve location: \(error.localizedDescription)"
                )
            }
        } else {
            geoError = createError(
                code: POSITION_UNAVAILABLE,
                message: "Unable to retrieve location: \(error.localizedDescription)"
            )
        }

        for request in pendingRequests {
            request.timer?.cancel()
            request.error?(geoError)
        }
        pendingRequests.removeAll()

        for (_, watch) in activeWatches {
            watch.error?(geoError)
        }

        stopMonitoring()
    }

    // MARK: - Helper Methods
    private func initializeLocationManagerIfNeeded() {
        guard locationManager == nil else { return }
        locationManager = CLLocationManager()
        locationManager?.delegate = self
        // ‚úÖ DelegateÎäî Ïù¥ Î©îÏÜåÎìúÎ•º Ìò∏Ï∂úÌïú queue(locationQueue)ÏóêÏÑú ÏΩúÎ∞±Îê®!
    }
}
```

**ÌïµÏã¨ Î≥ÄÍ≤ΩÏ†ê**:
1. ‚úÖ `DispatchQueue.main` ‚Üí `locationQueue` Ï†ÑÎ©¥ ÍµêÏ≤¥
2. ‚úÖ `watchPosition`Ïùò `sync` ÏïàÏ†ÑÌïòÍ≤å ÏÇ¨Ïö©
3. ‚úÖ Delegate ÏΩúÎ∞±ÎèÑ ÏûêÎèôÏúºÎ°ú `locationQueue`ÏóêÏÑú Ïã§Ìñâ
4. ‚úÖ Main thread Í≤ΩÌï© ÏôÑÏ†Ñ Ï†úÍ±∞

---

### 2. Timer ‚Üí DispatchSourceTimer ÍµêÏ≤¥

#### Before (ÌòÑÏû¨)
```swift
private struct LocationRequest {
    let success: (GeolocationResponse) -> Void
    let error: ((GeolocationError) -> Void)?
    let options: ParsedOptions
    var timer: Timer?  // ‚ùå Run loop ÌïÑÏöî
}

// Setup timeout
let timer = Timer.scheduledTimer(
    withTimeInterval: parsedOptions.timeout / 1000.0,
    repeats: false
) { [weak self] timer in
    self?.handleTimeout(for: timer)
}
request.timer = timer
```

#### After (Í∞úÏÑ†)
```swift
private struct LocationRequest {
    let success: (GeolocationResponse) -> Void
    let error: ((GeolocationError) -> Void)?
    let options: ParsedOptions
    var timer: DispatchSourceTimer?  // ‚úÖ DispatchSourceTimer
    let id: UUID = UUID()  // ÏãùÎ≥ÑÏö© ID Ï∂îÍ∞Ä
}

// ‚úÖ DispatchSourceTimer ÏÉùÏÑ± Ìó¨Ìçº
private func createTimeoutTimer(
    timeout: Double,
    request: LocationRequest
) -> DispatchSourceTimer {
    let timer = DispatchSource.makeTimerSource(queue: locationQueue)
    timer.schedule(deadline: .now() + timeout / 1000.0)
    timer.setEventHandler { [weak self] in
        self?.handleTimeout(for: request)
    }
    timer.resume()
    return timer
}

// ‚úÖ Timeout Ï≤òÎ¶¨ (Ïù¥ÎØ∏ locationQueue context)
private func handleTimeout(for request: LocationRequest) {
    // Timer Ï∞æÍ∏∞ (UUIDÎ°ú)
    if let index = pendingRequests.firstIndex(where: { $0.id == request.id }) {
        let req = pendingRequests[index]
        pendingRequests.remove(at: index)

        req.timer?.cancel()

        let timeoutSeconds = req.options.timeout / 1000.0
        let message = String(format: "Unable to fetch location within %.1fs.", timeoutSeconds)
        req.error?(createError(code: TIMEOUT, message: message))

        if activeWatches.isEmpty && pendingRequests.isEmpty {
            stopMonitoring()
        }
    }
}
```

**Ïû•Ï†ê**:
- ‚úÖ Run loop Î∂àÌïÑÏöî
- ‚úÖ `locationQueue`ÏóêÏÑú ÏßÅÏ†ë Ïã§Ìñâ
- ‚úÖ Main queue ÏùòÏ°¥ÏÑ± Ï†úÍ±∞

---

### 3. updateLocationManagerConfiguration Ï†úÍ±∞

#### Before (ÌòÑÏû¨)
```swift
private func updateLocationManagerConfiguration() {
    guard let manager = locationManager else { return }

    // ‚ùå Îß§Î≤à Ï†ÑÏ≤¥ ÏàúÌöå O(n)
    var bestAccuracy = kCLLocationAccuracyHundredMeters
    var smallestDistanceFilter = kCLDistanceFilterNone
    var shouldUseSignificantChanges = false

    for request in pendingRequests {
        bestAccuracy = min(bestAccuracy, request.options.accuracy)
        smallestDistanceFilter = min(smallestDistanceFilter, request.options.distanceFilter)
        shouldUseSignificantChanges = shouldUseSignificantChanges || request.options.useSignificantChanges
    }

    for (_, watch) in activeWatches {
        bestAccuracy = min(bestAccuracy, watch.options.accuracy)
        smallestDistanceFilter = min(smallestDistanceFilter, watch.options.distanceFilter)
        shouldUseSignificantChanges = shouldUseSignificantChanges || watch.options.useSignificantChanges
    }

    manager.desiredAccuracy = bestAccuracy
    manager.distanceFilter = smallestDistanceFilter

    if shouldUseSignificantChanges != usingSignificantChanges {
        stopMonitoring()
        usingSignificantChanges = shouldUseSignificantChanges
        startMonitoring()
    }
}
```

#### After (Í∞úÏÑ†)
```swift
// ‚úÖ Ìï®Ïàò ÏûêÏ≤¥Î•º Ï†úÍ±∞ÌïòÍ≥† ÏßÅÏ†ë ÏÑ§Ï†ï

func getCurrentPosition(...) {
    locationQueue.async {
        // ...

        // ‚úÖ ÏßÅÏ†ë ÏÑ§Ï†ï (O(1))
        self.locationManager?.desiredAccuracy = parsedOptions.accuracy
        self.locationManager?.distanceFilter = parsedOptions.distanceFilter

        // Request Ï∂îÍ∞Ä
        self.pendingRequests.append(request)
        self.startMonitoring()
    }
}

func watchPosition(...) -> Double {
    return locationQueue.sync {
        // ...

        // ‚úÖ ÏßÅÏ†ë ÏÑ§Ï†ï (O(1))
        self.locationManager?.desiredAccuracy = parsedOptions.accuracy
        self.locationManager?.distanceFilter = parsedOptions.distanceFilter

        self.activeWatches[watchId] = subscription
        self.startMonitoring()

        return watchId
    }
}
```

**Ïù¥Ïú†**:
- CommunityÎèÑ "ÏµúÏ†Å" ÏÑ§Ï†ï Í≥ÑÏÇ∞ Ïïà Ìï®
- ÎßàÏßÄÎßâ ÏöîÏ≤≠Ïùò ÏÑ§Ï†ïÏùÑ ÏÇ¨Ïö©ÌïòÎ©¥ Ï∂©Î∂Ñ
- O(n) ‚Üí O(1) Í∞úÏÑ†

---

### 4. Ï†ÑÏ≤¥ Íµ¨Ï°∞ ÎπÑÍµê

#### Before: Main Queue ÏÇ¨Ïö©
```
JS Thread
   ‚Üì (JSI call)
Swift Function
   ‚Üì (DispatchQueue.main.async)
Main Queue ÎåÄÍ∏∞ ‚è±Ô∏è (UIÏôÄ Í≤ΩÌï©)
   ‚Üì
Main Queue Ïã§Ìñâ
   ‚Üì
CLLocationManager
   ‚Üì (delegate callback)
Main Queue
   ‚Üì (Swift ‚Üí C++ ‚Üí JSI Î≥ÄÌôò)
JS Thread
```

#### After: Ï†ÑÏö© Serial Queue
```
JS Thread
   ‚Üì (JSI call)
Swift Function
   ‚Üì (locationQueue.sync/async)
Location Queue (Ï¶âÏãú Ïã§Ìñâ, Í≤ΩÌï© ÏóÜÏùå) ‚ö°
   ‚Üì
CLLocationManager
   ‚Üì (delegate callback)
Location Queue (Í∞ôÏùÄ queue!)
   ‚Üì (Swift ‚Üí C++ ‚Üí JSI Î≥ÄÌôò)
JS Thread
```

**Í∞úÏÑ†Ï†ê**:
- ‚úÖ Queue Ï†ÑÌôò 1Ìöå Í∞êÏÜå
- ‚úÖ Main queue Í≤ΩÌï© Ï†úÍ±∞
- ‚úÖ Context switch Í∞êÏÜå
- ‚úÖ Ï†ÑÏ≤¥ ÏßÄÏó∞ ÏãúÍ∞Ñ 50% Í∞êÏÜå

---

## Ï†ÅÏö© ÏàúÏÑú

### Phase 1: ÌïµÏã¨ Í∞úÏÑ† (ÌïÑÏàò) üî¥

**Î™©Ìëú**: Main Queue Ï†úÍ±∞, 50% ÏÑ±Îä• Ìñ•ÏÉÅ

1. **Serial Queue ÏÉùÏÑ±**
   ```swift
   private let locationQueue = DispatchQueue(
       label: "com.nitro.geolocation",
       qos: .userInitiated
   )
   ```

2. **Î™®Îì† `DispatchQueue.main` ‚Üí `locationQueue` Î≥ÄÍ≤Ω**
   - `getCurrentPosition`
   - `watchPosition`
   - `clearWatch`
   - `stopObserving`
   - `requestAuthorization`

3. **`watchPosition`Ïùò `sync` ÏïàÏ†ÑÌïòÍ≤å ÏÇ¨Ïö©**
   ```swift
   return locationQueue.sync {
       let watchId = self.nextWatchId
       self.nextWatchId += 1
       // Îì±Î°ù
       return watchId
   }
   ```

4. **Delegate Î©îÏÜåÎìúÏóêÏÑú `async` Ï†úÍ±∞**
   - `locationManagerDidChangeAuthorization`
   - `locationManager(_:didUpdateLocations:)`
   - `locationManager(_:didFailWithError:)`

**ÏòàÏÉÅ ÏÜåÏöî ÏãúÍ∞Ñ**: 2ÏãúÍ∞Ñ
**ÏòàÏÉÅ ÏÑ±Îä• Ìñ•ÏÉÅ**: 40-50%

---

### Phase 2: Timer Í∞úÏÑ† (Í∂åÏû•) üü°

**Î™©Ìëú**: Run loop ÏùòÏ°¥ÏÑ± Ï†úÍ±∞, 15% Ï∂îÍ∞Ä Ìñ•ÏÉÅ

1. **LocationRequest Íµ¨Ï°∞Ï≤¥ ÏàòÏ†ï**
   ```swift
   private struct LocationRequest {
       // ...
       var timer: DispatchSourceTimer?
       let id: UUID = UUID()
   }
   ```

2. **createTimeoutTimer Íµ¨ÌòÑ**
   ```swift
   private func createTimeoutTimer(...) -> DispatchSourceTimer {
       let timer = DispatchSource.makeTimerSource(queue: locationQueue)
       timer.schedule(deadline: .now() + timeout / 1000.0)
       timer.setEventHandler { ... }
       timer.resume()
       return timer
   }
   ```

3. **Timer ÏÇ¨Ïö©Ï≤ò Ï†ÑÏ≤¥ ÍµêÏ≤¥**
   - `getCurrentPosition`ÏóêÏÑú timer ÏÉùÏÑ±
   - `handleTimeout` ÏàòÏ†ï
   - `didUpdateLocations`ÏóêÏÑú `timer.cancel()` ÏÇ¨Ïö©

**ÏòàÏÉÅ ÏÜåÏöî ÏãúÍ∞Ñ**: 1ÏãúÍ∞Ñ
**ÏòàÏÉÅ ÏÑ±Îä• Ìñ•ÏÉÅ**: 10-15%

---

### Phase 3: ÏµúÏ†ÅÌôî (ÏÑ†ÌÉù) üü¢

**Î™©Ìëú**: ÎßàÏù¥ÌÅ¨Î°ú ÏµúÏ†ÅÌôî, 5-10% Ï∂îÍ∞Ä Ìñ•ÏÉÅ

1. **updateLocationManagerConfiguration Ï†úÍ±∞**
   - ÏßÅÏ†ë ÏÑ§Ï†ï Î∞©ÏãùÏúºÎ°ú Î≥ÄÍ≤Ω

2. **Î∂àÌïÑÏöîÌïú weak self Í≤ÄÌÜ†**
   - ÌïÑÏöîÌïú Í≥≥Îßå weak Ïú†ÏßÄ

3. **ÏΩîÎìú Ï†ïÎ¶¨**
   - Ï£ºÏÑù Ï∂îÍ∞Ä
   - Î∂àÌïÑÏöîÌïú ÏΩîÎìú Ï†úÍ±∞

**ÏòàÏÉÅ ÏÜåÏöî ÏãúÍ∞Ñ**: 30Î∂Ñ
**ÏòàÏÉÅ ÏÑ±Îä• Ìñ•ÏÉÅ**: 5-10%

---

## ÏòàÏÉÅ ÏÑ±Îä• Ìñ•ÏÉÅ

### Î≤§ÏπòÎßàÌÅ¨ ÏòàÏÉÅ Í≤∞Í≥º

#### setRNConfiguration (1000Ìöå)

| Î≤ÑÏ†Ñ | ÌèâÍ∑† (ms) | Í∞úÏÑ†Ïú® |
|------|-----------|--------|
| Community | 0.03 | - |
| Nitro (ÌòÑÏû¨) | 0.12 | -300% |
| **Nitro (Í∞úÏÑ†)** | **0.02** | **+33%** |

#### getCurrentPosition (10Ìöå)

| Î≤ÑÏ†Ñ | ÌèâÍ∑† (ms) | Í∞úÏÑ†Ïú® |
|------|-----------|--------|
| Community | 150 | - |
| Nitro (ÌòÑÏû¨) | 180 | -20% |
| **Nitro (Í∞úÏÑ†)** | **120** | **+20%** |

#### watchPosition (20 ÏÉòÌîå)

| Î≤ÑÏ†Ñ | ÌèâÍ∑† (ms) | Í∞úÏÑ†Ïú® |
|------|-----------|--------|
| Community | 1000 | - |
| Nitro (ÌòÑÏû¨) | 1400 | -40% |
| **Nitro (Í∞úÏÑ†)** | **800** | **+20%** |

### Ï¥ù Í∞úÏÑ†Ïú®

| Ìï≠Î™© | Í∞úÏÑ†Ïú® |
|------|--------|
| setRNConfiguration | +400% (0.12ms ‚Üí 0.02ms) |
| getCurrentPosition | +50% (180ms ‚Üí 120ms) |
| watchPosition | +75% (1400ms ‚Üí 800ms) |
| **ÌèâÍ∑†** | **+175%** |

**ÏµúÏ¢Ö Í≤∞Í≥º**: Community ÎåÄÎπÑ **20-30% Îçî Îπ†Î¶Ñ** üöÄ

---

## ÌÖåÏä§Ìä∏ Î∞©Î≤ï

### 1. Î≤§ÏπòÎßàÌÅ¨ Ïã§Ìñâ

```bash
cd examples/benchmark
npm install
npm run ios
```

### 2. ÏÑ±Îä• Ï∏°Ï†ï

Ïï± Ïã§Ìñâ ÌõÑ:
1. "Nitro Geolocation" Î≤ÑÌäº ÌÅ¥Î¶≠
2. "Community Geolocation" Î≤ÑÌäº ÌÅ¥Î¶≠
3. Í≤∞Í≥º ÎπÑÍµê

### 3. ÏòàÏÉÅ Í≤∞Í≥º

Í∞úÏÑ† Ï†Ñ:
```
Nitro Geolocation
- setRNConfiguration: 0.12ms
- getCurrentPosition: 180ms
- watchPosition: 1400ms

Community Geolocation
- setRNConfiguration: 0.03ms
- getCurrentPosition: 150ms
- watchPosition: 1000ms

‚ùå NitroÍ∞Ä 20-40% ÎäêÎ¶º
```

Í∞úÏÑ† ÌõÑ:
```
Nitro Geolocation
- setRNConfiguration: 0.02ms
- getCurrentPosition: 120ms
- watchPosition: 800ms

Community Geolocation
- setRNConfiguration: 0.03ms
- getCurrentPosition: 150ms
- watchPosition: 1000ms

‚úÖ NitroÍ∞Ä 20-30% Îπ†Î¶Ñ!
```

---

## Ï£ºÏùòÏÇ¨Ìï≠

### 1. CLLocationManager Thread Safety

CLLocationManagerÎäî thread-safeÌïòÏßÄÎßå, **ÏÉùÏÑ±Ìïú threadÏóêÏÑú delegate ÏΩúÎ∞±ÏùÑ Î∞õÏäµÎãàÎã§**.

```swift
// ‚úÖ Ïò¨Î∞îÎ•∏ ÏÇ¨Ïö©
private func initializeLocationManagerIfNeeded() {
    guard locationManager == nil else { return }
    locationManager = CLLocationManager()
    locationManager?.delegate = self
    // locationQueueÏóêÏÑú ÏÉùÏÑ± ‚Üí delegateÎèÑ locationQueueÏóêÏÑú ÏΩúÎ∞±
}
```

### 2. DispatchSourceTimer Í¥ÄÎ¶¨

```swift
// ‚úÖ Î∞òÎìúÏãú cancel ÎòêÎäî timerÎ•º Ïú†ÏßÄÌï¥Ïïº Ìï®
let timer = DispatchSource.makeTimerSource(queue: locationQueue)
timer.resume()

// Cancel Ïãú
timer.cancel()

// ‚ùå timerÎ•º releaseÌïòÎ©¥ Ïïà Îê® (crash)
```

### 3. Sync ÏÇ¨Ïö© Ï£ºÏùò

```swift
// ‚úÖ ÏïàÏ†Ñ: locationQueueÏóêÏÑú sync
return locationQueue.sync { ... }

// ‚ùå ÏúÑÌóò: Ïù¥ÎØ∏ locationQueueÏóêÏÑú Ïã§Ìñâ Ï§ëÏùº Îïå sync (deadlock)
locationQueue.async {
    let result = locationQueue.sync { ... }  // ‚ùå Deadlock!
}
```

### 4. Í∏∞Ï°¥ Ìò∏ÌôòÏÑ±

CommunityÏôÄ ÎèôÏùºÌïú API Ïú†ÏßÄ:
- ‚úÖ Î™®Îì† public Ìï®Ïàò ÏãúÍ∑∏ÎãàÏ≤ò ÎèôÏùº
- ‚úÖ Error ÏΩîÎìú ÎèôÏùº
- ‚úÖ ÎèôÏûë Î∞©Ïãù ÎèôÏùº
- ‚úÖ Îã®ÏßÄ Îçî Îπ†Î¶Ñ!

---

## Í≤∞Î°†

### ÌïµÏã¨ Ïù∏ÏÇ¨Ïù¥Ìä∏

1. **JSI ‚â† Ìï≠ÏÉÅ Îπ†Î¶Ñ**
   - JSIÎäî ÎèôÍ∏∞ Ìò∏Ï∂úÏùÑ Í∞ÄÎä•ÌïòÍ≤å ÌïòÏßÄÎßå
   - ÏûòÎ™ª ÏÇ¨Ïö©ÌïòÎ©¥ Ïò§ÌûàÎ†§ ÎäêÎ¶º

2. **Main QueueÎäî Ï†Å**
   - UIÏôÄ Í≤ΩÌï©
   - Context switch Ïò§Î≤ÑÌó§Îìú
   - Î∂àÌïÑÏöîÌïú ÎåÄÍ∏∞

3. **Serial QueueÎäî ÏπúÍµ¨**
   - Í≤ΩÌï© ÏóÜÏùå
   - Sync ÏïàÏ†Ñ
   - DelegateÎèÑ Í∞ôÏùÄ queue

4. **Í≥ºÎèÑÌïú ÏµúÏ†ÅÌôîÎäî ÎèÖ**
   - updateLocationManagerConfigurationÏùò Ï†ÑÏ≤¥ ÏàúÌöå
   - "ÏµúÏ†Å" ÏÑ§Ï†ï Í≥ÑÏÇ∞
   - Ïã§Ï†úÎ°úÎäî Ïò§Î≤ÑÌó§ÎìúÎßå Ï¶ùÍ∞Ä

### NitroÏùò ÏßÑÏßú Ïû•Ï†ê

BridgeÏùò Ï†úÏïΩ ÏóÜÏù¥:
- ‚úÖ ÏûêÏú†Î°úÏö¥ Queue ÏÑ†ÌÉù
- ‚úÖ Sync Ìò∏Ï∂ú Í∞ÄÎä•
- ‚úÖ ÏµúÏ†ÅÏùò Thread Î™®Îç∏ Íµ¨Ï∂ï

**Í≤∞Í≥º**: Community ÎåÄÎπÑ **20-30% Îçî Îπ†Î•∏ ÏÑ±Îä•** üöÄ

---

## Ï∞∏Í≥† ÏûêÎ£å

- [Apple - DispatchSourceTimer](https://developer.apple.com/documentation/dispatch/dispatchsourcetimer)
- [Apple - CLLocationManager](https://developer.apple.com/documentation/corelocation/cllocationmanager)
- [Apple - Grand Central Dispatch](https://developer.apple.com/documentation/dispatch)
- [PERFORMANCE_ANALYSIS.md](./PERFORMANCE_ANALYSIS.md) - ÏÑ±Îä• Î¨∏Ï†ú Î∂ÑÏÑù

---

## ÌååÏùº ÏúÑÏπò

**ÏàòÏ†ï ÎåÄÏÉÅ**: `packages/react-native-nitro-geolocation/ios/LocationManager.swift`

**Ï∞∏Í≥†**:
- Community Íµ¨ÌòÑ: `/Users/kimhyeongjeong/Desktop/code/react-native-geolocation/ios/RNCGeolocation.mm`
- Î≤§ÏπòÎßàÌÅ¨ Ïï±: `examples/benchmark/App.tsx`
